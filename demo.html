<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>闭包的规范使用以及原理</title>
		<link href="../../../public/font/font.css" rel="stylesheet" />
		
	</head>
	<body>
		<h2>闭包的规范使用以及原理</h2>
		<div style="padding-left:25px;">
    <p >
	 在了解闭包之前先了解一下目前主流对闭包的定义：<br><br>
	 1.闭包是指有权访问另一个函数作用域中的变量的 函数 。（Nicolas C.Zaka）<br>
	 2.当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函 数持有对该词法作用域的引用，这个 引用 就叫做 闭包。（KYLE SIMPSON）<br>
	</p>
	<p>
	 本人从理解角度来将更赞同后者的定义，从个人角度来讲，后者的定义能对于学习和应用者来说会更容易理解一点。<br>
	 接下来首先了解下闭包中所涉及到的几个核心的知识点和概念,对于基础知识比较薄弱的开发者来说将会比较容易理解，涉及到一下几个概念：<br><br>
	 1.JavaScript的作用域链和作用域。<br>
	 2.JavaScript的标识符查找机制。<br>
	 3.JavaScript的函数表达式和函数声明。<br>
	 4.JavaScript的垃圾回收机制。<br>
	     </p >
			<h5>作用域链，作用域</h5>
			 <p >
				 作用域链就是指在调用变量或者函数时产生的搜索域的过程。<br>
					JavaScript的作用域就是词法作用域而不是动态作用域 <br>
					词法作用域最重要的特征是它的定义过程发生在 代码的书写阶段。 <br>
					动态作用域的作用域链是基于 调用栈的 词法作用域的作用域链是基于 代码中的作用域嵌套。<br>
					
				  </p >
				  <p>
					  举例说明：<br>
					  function fn1(){<br>
						  console.log('我是函数1的');<br>
						  console.log(infor);<br>
					  }<br>
					  function fn2(){<br>
						var infor = '我是函数2的';<br>
						fn1();<br>
					  }<br>
					  var infor = '我是全局的';<br>
					  fn2();<br>
					
				  </p>
				  <p>这个会输出是么呢？<br>
					  //我是函数1的<br>
					  //我是全局的<br>
					  当fn2执行的时候，会执行fn1，同时在fn2中定义一个局部变量infor,在执行fn1时，调用到输出变量infor时，
					  因为JavaScript是词法作用域，所以函数fn1执行时，会沿着定 义时的作用域链查找变量，而不是执行时，
					  fn1函数定义在全局中，所以查找到了全局的infor， 输出了'我是全局的'而不是'我是函数2的'。
					  
				  </p>
			<h5>标识符查找机制</h5>
			 <p >
			作用域链在本质上就是 指向变量对象的指针列表，只引用但是不实际包含变量对象，变量、函数等都存在于各自作用域的变量对象中，通过访问变量对象来访问它们。 </br>
			只有在函数调用的时候，才会创建执行的环境和作用域链，与此同时每个相关环境都只能逐级向上搜索作用域链，来查询变量名和函数名等标识符，也就是在调用到一个变量或者函数的时候，会先在自己 的作用域中去查找，如果存在就使用，如果不存在就去自己
			作用域的父作用域中去搜索，以此类推直到搜索到调用变量或者函数。
 </br>

<h5>函数表达式，函数声明</h5>
<p >
	var fn = function(){};//函数表达式<br>
	或者这样：<br>
	var fn = function hand(){};//函数表达式<br>
	两者的区别是前者是匿名的函数表达式，后者是具名的函数表达式。<br>
	function hand(){};//函数声明<br>
	还有一种大家常见的使用方法：<br>
	(function(){})();//这也是函数表达式，是立即执行函数。<br>
	函数声明和函数表达式的区别：<br>
	（1）函数表达式可以在后面加个‘（）’立即执行，但是函数声明不可以。<br>
	（2）函数声明具有函数声明提升，而函数表达式不会。<br>
	注：关于函数和变量声明的提升不了解的可以查阅下相关资料。<br>
	 </p >
	 <h5>垃圾回收机制</h5>
	 <p >
			JavaScript最常用的垃圾收集方式是标记清除，垃圾收集器会给存储在内存中的所有变量都加
			上标记，然后去除环境中的变量，以及被环境中的变量引用的变量的标记，说明这些变量还有 作用，暂时不能被删除，然后在此之后被加上标记的变量就是要删除的变量了，等待垃圾收集 器对他们完成清除工作。
			<br>对函数来说，函数执行完毕后，会自动释放掉里面的变量，可是如果函数内部存在闭包，它们 就不会被删除，因为这个函数还在被内部的函数所引用，所以他不会被加上标记，不会被清 除，而是会 一直存在内存中得不到释放！ 除非使用闭包的那个内部函数被销毁，外部函数才能得 到释放
			<br/>这也是闭包存在和使用所依赖的核心机制，
			所以，虽然闭包强大，但是我们不能滥用它，且在没有必要的情况下尽量不要创建闭包，不然 将会有大量的变量对象得不到释放，过度占用内存。
			下来举个例子说明：
			
		  </p >	
</div>
	<script>
		(function(){})();
		var a = (function(){return 1;}());
		alert(a);
	</script>
	</body>
</html>

